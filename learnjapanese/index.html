<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>JP Mini Drills ‚Äî Demonstratives & Particles</title>
<style>
  :root{
    --bg:#0f1115;--panel:#151922;--text:#e6e6e6;--muted:#a9b0be;--accent:#5b9cff;--ok:#23c26b;--bad:#ff5e7e;--bar:#232838;--chip:#1e2431;--focus:#8ab4ff;
    --tile0:#FFFFFF;--tile1:#eaf7ee;--tile2:#d5efdd;--tile3:#bde5c8;--tile4:#a6dbb4;--tile5:#8fd1a0;--tile6:#73c488;--tile7:#52b371;--tile8:#319f58;--tile9:#148942;
  }
  body.light{
    --bg:#f7f8fb;--panel:#ffffff;--text:#0b1220;--muted:#55607a;--accent:#356dff;--ok:#1a9c5a;--bad:#e04968;--bar:#e6e9f2;--chip:#eef1f7;--focus:#2c60ff;
  }
  html,body{height:100%}
  body{margin:0;background:var(--bg);color:var(--text);font:16px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial}
  .wrap{max-width:880px;margin:0 auto;padding:16px 20px 28px}
  h1{font-size:22px;margin:0}
  h2{font-size:18px;margin:16px 0 8px;color:var(--muted)}
  .card{background:var(--panel);border:1px solid #20253422;border-radius:16px;padding:16px;box-shadow:0 8px 24px rgba(0,0,0,.18)}
  .row{display:flex;gap:12px;flex-wrap:wrap;align-items:center}
  .grid{display:grid;gap:12px}
  .grid.cols-2{grid-template-columns:repeat(2,minmax(0,1fr))}
  .grid.cols-3{grid-template-columns:repeat(3,minmax(0,1fr))}
  .btn{background:#1f2633;border:1px solid #2a3141;color:var(--text);padding:10px 14px;border-radius:10px;cursor:pointer}
  body.light .btn{background:#f0f3fa;border-color:#d7deec;color:#0b1220}
  .btn:hover{filter:brightness(1.05)}
  .btn.primary{background:var(--accent);border-color:#4b87e5;color:#0b1220}
  .btn.good{background:var(--ok);border-color:#1c9a56;color:#042015}
  .btn.bad{background:var(--bad);border-color:#e24b6a;color:#24050b}
  body.light .btn.bad{background:var(--bad)!important;border-color:#e24b6a!important;color:#24050b!important}
  .btn.sound{min-width:42px;text-align:center}
  .btn.sound.muted{background:var(--text);color:var(--bg);border-color:var(--text)}
  .btn.furi.on{background:var(--text);color:var(--bg);border-color:var(--text)}
  select, input[type="number"]{background:#1f2633;border:1px solid #2a3141;color:var(--text);padding:10px;border-radius:10px}
  body.light select, body.light input[type="number"]{background:#f0f3fa;border-color:#d7deec;color:#0b1220}
  .bar{height:10px;background:var(--bar);border-radius:999px;overflow:hidden}
  .bar>span{display:block;height:100%;background:linear-gradient(90deg,#6fa8ff,#8d7dff);width:0%}
  .q{font-size:28px;letter-spacing:.5px}
  .options{display:grid;gap:10px;margin-top:12px}
  .options button{font-size:16px;text-align:left}
  .option.correct{background:var(--ok)!important;color:#062012}
  .option.wrong{background:var(--bad)!important;color:#2a0007}
  .hud{display:flex;gap:12px;flex-wrap:wrap;color:var(--muted);font-size:14px;align-items:center}
  .feedback{margin-top:10px;font-weight:600}
  .feedback.good{color:var(--ok)}
  .feedback.bad{color:var(--bad)}
  .chips{display:flex;gap:8px;flex-wrap:wrap}
  .chip{background:var(--chip);border:1px solid #2a3141;border-radius:999px;padding:6px 10px;color:var(--muted);font-size:12px}
  body.light .chip{background:#eef1f7;border-color:#d7deec;color:#55607a}
  .muted{color:var(--muted)}
  .topbar{
    position:static;background:var(--bg);padding:10px 0 12px;margin-bottom:12px;
    display:flex;justify-content:space-between;align-items:center;border-bottom:1px solid transparent;
  }
  .title{display:flex;gap:10px;align-items:center}
  .heat{display:grid;grid-template-columns:repeat(10,1fr);gap:6px}
  .tile{height:18px;border-radius:6px;border:1px solid #222}
  .ref{font-size:14px}
  .ref table{width:100%;border-collapse:collapse}
  .ref th,.ref td{border:1px solid #233;padding:6px 8px}
  body.light .ref th, body.light .ref td{border-color:#dbe1ef}
  .ref th{background:#1b202c;color:#aeb6c8}
  body.light .ref th{background:#f2f5fb;color:#55607a}
  .subcard{background:#1a2030;border:1px solid #2a3141;border-radius:16px;padding:12px}
  body.light .subcard{background:#ffffff;border-color:#d7deec}
  .hintbox{margin-top:8px}
  .flash{min-height:260px;display:flex;flex-direction:column;justify-content:center;align-items:center;gap:8px;font-size:26px}
  .flash .front{font-size:32px}
  .legend{display:flex;align-items:center;gap:8px;margin-top:12px}
  .ref a{ color: inherit; text-decoration: underline; text-underline-offset: 2px; }
  .ref a:hover{ filter: brightness(1.1); }
  /* selection popup */
  .selpop{
    position:fixed;z-index:9999;background:var(--panel);color:var(--text);
    border:1px solid #2a3141;border-radius:10px;box-shadow:0 10px 30px rgba(0,0,0,.25);
    padding:10px 12px;max-width:300px
  }
  .selpop .tt{font-weight:700;margin-bottom:4px}
  .selpop .ex{color:var(--muted);margin-top:2px}
  .mc-delta.up{ color: var(--ok) }
  .mc-delta.down{ color: var(--bad) }
  .mc-delta.flat{ opacity: .6 }
  ruby{ruby-position:over}
  rt{font-size:.6em;color:var(--muted);line-height:1}

    /* ===== Mobile ===== */
    @media (max-width: 600px){
    .wrap{ padding:12px 14px 24px }
    .topbar{ flex-direction:column; align-items:flex-start; gap:8px }
    .title h1{ font-size:20px }
    #topHud{ width:100%; display:flex; flex-wrap:wrap; gap:8px }
    .chip{ font-size:11px; padding:5px 8px }
    .btn{ padding:8px 10px; font-size:14px }
    select, input[type="number"]{ padding:8px; font-size:14px }
    .grid.cols-3{ grid-template-columns:1fr }   /* menu cards stack */
    .flash{ font-size:22px }
    .flash .front{ font-size:28px }
    .ref table{ display:block; overflow-x:auto; }
    }

    /* ===== Bottom glossary bar (mobile-friendly) ===== */
    /* ===== Bottom glossary bar (mobile-first) ===== */
    .glossbar{
    position:fixed;
    left:16px; right:16px;
    bottom: calc(env(safe-area-inset-bottom) + 116px); /* sits in that empty space */
    background:var(--panel);
    border:1px solid #2a3141;
    border-radius:14px;
    padding:10px;
    box-shadow:0 12px 28px rgba(0,0,0,.28);
    display:none;
    z-index:1000; /* above cards */
    }
    .glossbar .chips{ display:flex; gap:8px; flex-wrap:wrap }
    .glossbar .chip{ background:#1f2633; border:1px solid #2a3141; color:var(--text) }
    body.light .glossbar .chip{ background:#f0f3fa; border-color:#d7deec; color:#0b1220 }

    @media (min-width: 601px){
    .glossbar{ bottom: 28px; left: 24px; right: 24px; }
    }


    /* Kill double-tap zoom on tappable controls */
    a, button, .btn, select, input, .options button, .chip {
    touch-action: manipulation;
    }



</style>
</head>
<body>
  <div class="wrap">
    <div class="topbar">
      <div class="title"><h1>JP Mini Drills</h1><span class="chip" id="modeChip"></span></div>
      <div class="hud" id="topHud">
        <span id="scoreHud"></span>
        <span id="streakHud"></span>
        <button class="btn sound" id="soundBtn">üîä</button>
        <button class="btn furi" id="furiBtn">„Åµ„Çä„Åå„Å™</button>
        <button class="btn" id="themeBtn">Dark/Light</button>
      </div>
    </div>
    <div id="app" class="grid"></div>
  </div>

<script>
// ======================= DATA (loaded) =======================
let DECK = [];       // full list of cards
let DEMO = [];       // demonstratives slice
let PARTICLES = [];  // particles slice
let LEX = {};        // jp -> gloss (deck + extras)
let LEX_KEYS = [];   // longest-first
const KANJILEX = { 'ÁßÅ':'I; private','Â≠¶':'study','Ê†°':'school','Áîü':'life; student','ÂÜó':'superfluous','Ë´á':'talk','Â±±':'mountain','Èõ®':'rain','ÈÅì':'road','ÈßÖ':'station','Â∫ó':'shop' };

async function loadData(){
  const deckRes = await fetch('data/deck.json');
  DECK = await deckRes.json();
  DEMO = DECK.filter(c=>c.cat==='demonstrative');
  PARTICLES = DECK.filter(c=>c.cat==='particle');

  // deck-derived lexicon
  const deckMap = {};
  DECK.forEach(c=>{ if(c.jp && c.en && !deckMap[c.jp]) deckMap[c.jp]=c.en; });

  // extras
  let extras = {};
  try{
    const lexRes = await fetch('data/lexicon.json');
    if(lexRes.ok) extras = await lexRes.json();
  }catch(e){}

  // merge extras (deck wins on collision)
  LEX = {...extras, ...deckMap};
  LEX_KEYS = Object.keys(LEX).sort((a,b)=>b.length-a.length);
}

let DATA_READY = false;

// ======================= STATE =======================
const S = {
  settings: load('settings', { prompt:'MIXED', qtype:'MCQ', category:'MIXED', size:20, theme:'dark', muted:false, furigana:false }),
  mastery: load('mastery', {}), // id -> {lvl,lastSeen,lastResult}
  stats: load('stats', { bestStreak:0 }),
  session: null,
  pending: [] // batched mastery updates
};
if(S.settings.theme==='light') document.body.classList.add('light');

// ======================= HELPERS =======================
const app = document.getElementById('app');
const modeChip = document.getElementById('modeChip');
const scoreHud = document.getElementById('scoreHud');
const streakHud = document.getElementById('streakHud');

document.getElementById('themeBtn').onclick=()=>{
  document.body.classList.toggle('light');
  S.settings.theme = document.body.classList.contains('light')? 'light':'dark';
  save('settings', S.settings);
};

const soundBtn = document.getElementById('soundBtn');
function updateSoundBtn(){
  soundBtn.textContent = S.settings.muted ? 'üîá' : 'üîä';
  soundBtn.classList.toggle('muted', S.settings.muted);
}
soundBtn.onclick=()=>{
  S.settings.muted = !S.settings.muted;
  save('settings', S.settings);
  updateSoundBtn();
};
updateSoundBtn();

const furiBtn = document.getElementById('furiBtn');
function updateFuriBtn(){ furiBtn.classList.toggle('on', !!S.settings.furigana); }

furiBtn.onclick = () => {
  S.settings.furigana = !S.settings.furigana;
  save('settings', S.settings);
  updateFuriBtn();

  const grp = app.dataset.refGroup;   
  if (grp) {                          
    viewRefFull(grp);                
  } else {
    render();                         
  }
};

function undoFlash(){
  const s = S.session;
  if(!s || s.kind !== 'FLASH' || !s.history || s.history.length === 0) return;

  const h = s.history.pop();

  // remove the last pending mastery update that matches this action
  for (let i = S.pending.length - 1; i >= 0; i--){
    const u = S.pending[i];
    if (u.id === h.cardId && u.ok === h.ok){ S.pending.splice(i,1); break; }
  }

  // revert stats
  s.answered = Math.max(0, s.answered - 1);
  if (h.ok) s.score = Math.max(0, s.score - 1);
  s.streak = h.prevStreak;
  s.maxStreak = h.prevMaxStreak;

  if(!h.ok){
    for(let i = s.mistakes.length - 1; i >= 0; i--){
      if(s.mistakes[i] === h.cardId){ s.mistakes.splice(i,1); break; }
    }
  }

  // show that card again (back side visible so user can re-decide fast)
  const card = [...DECK].find(c => c.id === h.cardId);
  s.current = { card, promptLang: h.frontLang, qtype: 'MCQ', options: [] };
  s.flipped = true;
  s.locked = false;

  render();
}



function setHud(){
  const s = S.session;
  modeChip.textContent = s ? `${S.settings.prompt} ¬∑ ${S.settings.qtype} ¬∑ ${S.settings.category}` : '';
  modeChip.style.display = s ? 'inline-flex' : 'none';

  const quizActive = !!s && (s.kind==='FIXED' || s.kind==='ENDLESS');
  scoreHud.style.display = quizActive ? 'inline' : 'none';
  streakHud.style.display = quizActive ? 'inline' : 'none';
  scoreHud.textContent = s? `Score: ${s.score}/${s.answered}` : '';
  streakHud.textContent = s? `Streak: ${s.streak}` : '';
}

/* Prevent double-tap zoom on iOS without killing pinch */
(function(){
  const isIOS = /iP(hone|ad|od)/.test(navigator.userAgent);
  if(!isIOS) return;

  // iOS fires zoom on dblclick; cancel it.
  document.addEventListener('dblclick', e => e.preventDefault(), { passive:false });

  // Extra guard: swallow the second tap if it lands within 300ms
  let lastTouch = 0;
  document.addEventListener('touchend', e => {
    const now = Date.now();
    if (now - lastTouch <= 300) { e.preventDefault(); }
    lastTouch = now;
  }, { passive:false });
})();


// ======================= SCHEDULER =======================
function weightFor(card){ const m=S.mastery[card.id]; const lvl=m?m.lvl:0; return 1/(1+lvl*lvl); }
function timeBoostFor(card){ const m=S.mastery[card.id]; if(!m) return 1; const days=(Date.now()-m.lastSeen)/86400000; return 1 + Math.min(Math.max(days,0)/14, 0.5); }
function recentPush(arr,id){ arr.push(id); if(arr.length>8) arr.shift(); }
function pickCard(pool, recent){
  const weights = pool.map(c=>({ c, w: weightFor(c) * timeBoostFor(c) }));
  const recentSet = new Set(recent);
  weights.forEach(o=>{ if(recentSet.has(o.c.id)) o.w *= 0.01; });
  const total = weights.reduce((s,o)=>s+o.w,0);
  let r = Math.random()*total;
  for(const o of weights){ r -= o.w; if(r<=0) return o.c; }
  return weights[weights.length-1].c;
}

// ======================= SESSION =======================
function currentPool(){ return (S.settings.category==='DEMONSTRATIVES'?DEMO:S.settings.category==='PARTICLES'?PARTICLES:[...DEMO,...PARTICLES]); }

function startSession(kind){
  const cat = S.settings.category;
  const pool = (cat==='DEMONSTRATIVES'?DEMO:cat==='PARTICLES'?PARTICLES:[...DEMO,...PARTICLES]);
  const size = kind==='ENDLESS'||kind==='FLASH'?Infinity:(S.settings.size||20);
  const qlist=[]; const used=new Set(); const recent=[];
  while(qlist.length < Math.min(size, pool.length)){
    const c = pickCard(pool, recent);
    if(!used.has(c.id)){ qlist.push(c); used.add(c.id); recentPush(recent,c.id); }
  }
  S.session = { kind, queue: qlist, idx:0, score:0, streak:0, maxStreak:0, mistakes:[], recent:[], started:Date.now(), answered:0, phase:'ASK', hintShown:false, flipped:false, locked:false, baseline: snapshotMastery(),history: [] };
  render();
}

function nextQuestion(){
  const s=S.session; const pool=currentPool();
  if(s.kind==='ENDLESS'||s.kind==='FLASH'){
    const c = pickCard(pool, s.recent);
    s.current = makeQuestion(c);
    recentPush(s.recent, c.id);
  }else{
    if(s.idx >= s.queue.length) return finish();
    const c = s.queue[s.idx]; s.current = makeQuestion(c);
  }
  s.phase='ASK'; s.hintShown=false; s.flipped=false; s.locked=false; render();
}

function makeQuestion(card){
  const promptLang = S.settings.prompt==='MIXED' ? (Math.random()<0.5?'EN':'JA') : S.settings.prompt;
  const opts=[card]; const pool=currentPool(); const candidates=pool.filter(x=>x.id!==card.id); shuffle(candidates);
  for(const c of candidates){ if(opts.length>=4) break; opts.push(c); }
  shuffle(opts);
  return { card, promptLang, qtype:S.settings.qtype, options:opts };
}

function submitAnswer(choiceIdx){
  const {card, options} = S.session.current;
  const correct = options[choiceIdx].id === card.id;
  grade(correct, choiceIdx);
}

function grade(correct, chosenIdx){
  const s=S.session; s.answered++;
  if(correct){ s.score++; s.streak++; if(s.streak>s.maxStreak) s.maxStreak=s.streak; }
  else{ s.streak=0; s.mistakes.push(s.current.card.id); }
  queueMasteryUpdate(s.current.card.id, correct);
  s.phase = correct? 'GOOD':'BAD';
  s.chosenIdx = chosenIdx;
}

function goNext(){
  const s=S.session;
  if(s.kind==='ENDLESS' || s.kind==='FLASH'){ nextQuestion(); return; }
  s.idx++; if(s.idx>=s.queue.length) finish(); else nextQuestion();
}

function finish(){
  applyPending();
  const s=S.session;

  // compute mastery deltas
  const before = s.baseline || snapshotMastery();
  const after  = snapshotMastery();
  const up=[],down=[];
  for(const id in after){
    const b=(before[id]|0), a=(after[id]|0);
    if(a>b) up.push({id,from:b,to:a});
    else if(a<b) down.push({id,from:b,to:a});
  }
  s.delta = {before,after,up,down};

  s.finished = { total:(s.kind==='ENDLESS'||s.kind==='FLASH'? s.answered : s.queue.length), duration: Date.now()-s.started };
  s.phase='DONE'; render();
}

// ======================= MASTERY =======================
function queueMasteryUpdate(id, ok){ S.pending.push({id, ok, ts: Date.now()}); }
function applyPending(){
  for(const u of S.pending){
    const cur = S.mastery[u.id] || { lvl:0, lastSeen:0, lastResult:'ok' };
    const lvl = Math.max(0, Math.min(9, cur.lvl + (u.ok? +1 : -1)));
    S.mastery[u.id] = { lvl, lastSeen: u.ts, lastResult: u.ok?'ok':'ng' };
  }
  S.pending = []; saveAll();
}

// ======================= STORAGE =======================
function load(key, fallback){ try{ const v=JSON.parse(localStorage.getItem(key)); return v??fallback; }catch(e){ return fallback; } }
function save(key, val){ localStorage.setItem(key, JSON.stringify(val)); }
function saveAll(){ save('settings', S.settings); save('mastery', S.mastery); save('stats', S.stats); }

// ======================= FURIGANA =======================
const FURIGANA = { // minimal readings used in examples; expand if you like
  '‰ªäÂπ¥':'„Åì„Å®„Åó','ÂéªÂπ¥':'„Åç„Çá„Å≠„Çì','ÂØí„ÅÑ':'„Åï„ÇÄ„ÅÑ','Êöë„ÅÑ':'„ÅÇ„Å§„ÅÑ','ÂÆâ„ÅÑ':'„ÇÑ„Åô„ÅÑ','È´ò„ÅÑ':'„Åü„Åã„ÅÑ','Ëøë„ÅÑ':'„Å°„Åã„ÅÑ',
  'Â±±':'„ÇÑ„Åæ','ÈÅì':'„Åø„Å°','ÈßÖ':'„Åà„Åç','Â∫ó':'„Åø„Åõ','ÂÆ∂':'„ÅÑ„Åà','Èõ®':'„ÅÇ„ÇÅ','Êñπ':'„Åã„Åü',
  'Êò†Áîª':'„Åà„ÅÑ„Åå','Èü≥Ê•Ω':'„Åä„Çì„Åå„Åè','ÂïèÈ°å':'„ÇÇ„Çì„Å†„ÅÑ','ÂÜóË´á':'„Åò„Çá„ÅÜ„Å†„Çì','ÊôØËâ≤':'„Åë„Åó„Åç','Á∑¥Áøí':'„Çå„Çì„Åó„ÇÖ„ÅÜ','Èõ£„Åó„ÅÑ':'„ÇÄ„Åö„Åã„Åó„ÅÑ',
  'ÂãâÂº∑':'„Åπ„Çì„Åç„Çá„ÅÜ','Â≠¶Ê†°':'„Åå„Å£„Åì„ÅÜ','Êù±‰∫¨':'„Å®„ÅÜ„Åç„Çá„ÅÜ','ÂèãÈÅî':'„Å®„ÇÇ„Å†„Å°','Êó•Êú¨':'„Å´„Åª„Çì','Âá∫Ë∫´':'„Åó„ÇÖ„Å£„Åó„Çì',
  'ÁßÅ':'„Çè„Åü„Åó','Â≠¶Áîü':'„Åå„Åè„Åõ„ÅÑ','Áå´':'„Å≠„Åì','Êú¨':'„Åª„Çì','Ë™≠„Åø„Åæ„Åô':'„Çà„Åø„Åæ„Åô','Ë®Ä„Å£„Åü':'„ÅÑ„Å£„Åü','ÊÄù„ÅÑ„Åæ„Åô':'„Åä„ÇÇ„ÅÑ„Åæ„Åô',
  'Èï∑„ÅÑ':'„Å™„Åå„ÅÑ','Â∫ß„Å£„Å¶':'„Åô„Çè„Å£„Å¶','‰Ωï':'„Å™„Å´','Âêç':'„ÇÅ„ÅÑ','Êßò':'„Åï„Åæ','Á∞°Âçò':'„Åã„Çì„Åü„Çì','Â•Ω„Åç':'„Åô„Åç','Ë¶ã„Åü„ÅÑ':'„Åø„Åü„ÅÑ',
  'ÊÄ•„Åå„Å™„Åè„Å¶':'„ÅÑ„Åù„Åå„Å™„Åè„Å¶','Ê∑∑„ÇÄ':'„Åì„ÇÄ','‰∏âÊôÇ':'„Åï„Çì„Åò','‰∫îÊôÇ':'„Åî„Åò','Ë°å„Åè':'„ÅÑ„Åè','Ë°å„Åã„Å™„ÅÑ':'„ÅÑ„Åã„Å™„ÅÑ','„ÅÑ„Çã':'„ÅÑ„Çã','‰∏Ä„Å§':'„Å≤„Å®„Å§'
};
const _FURI_KEYS = Object.keys(FURIGANA).sort((a,b)=>b.length-a.length);
function furiganaize(text){
  let out=text;
  for(const k of _FURI_KEYS){ out = out.split(k).join(`<ruby>${k}<rt>${FURIGANA[k]}</rt></ruby>`); }
  return out;
}
function renderJP(s){ return S.settings.furigana ? furiganaize(s) : s; }

// ======================= VIEWS =======================
function render(){
  app.innerHTML=''; setHud();
  if(!DATA_READY){
    const el=document.createElement('div'); el.className='card';
    el.innerHTML=`<div class='muted'>Loading deck‚Ä¶</div>`;
    app.appendChild(el); return;
  }
  if(!S.session){ return viewMenu(); }
  if(S.session.phase==='DONE'){ return viewResults(); }
  if(!S.session.current){ nextQuestion(); return; }
  if(S.session.kind==='FLASH'){ return viewFlash(); }
  viewQuiz();
}

function viewMenu(){
  const el=document.createElement('div'); el.className='grid';
  el.innerHTML=`
    <div class='card grid'>
      <div class='grid cols-3'>
        <div>
          <h2>Prompt</h2>
          <select id='promptSel'>
            <option value='EN'>EN ‚Üí JA</option>
            <option value='JA'>JA ‚Üí EN</option>
            <option value='MIXED'>Mixed</option>
          </select>
        </div>
        <div>
          <h2>Type</h2>
          <select id='qtypeSel'>
            <option value='MCQ'>Multiple Choice</option>
            <option value='TYPED' disabled>Type In (soon)</option>
          </select>
        </div>
        <div>
          <h2>Category</h2>
          <select id='catSel'>
            <option value='MIXED'>Mixed</option>
            <option value='DEMONSTRATIVES'>Demonstratives</option>
            <option value='PARTICLES'>Particles</option>
          </select>
        </div>
      </div>

      <div class='grid cols-3'>
        <div class='subcard'>
          <h2>Fixed Quiz</h2>
          <div class='row'>
            <label>Questions <input type='number' id='sizeInp' min='10' max='50' step='10' value='${S.settings.size||20}'></label>
            <button class='btn primary' id='startFixed'>Start</button>
          </div>
        </div>

        <div class='subcard'>
          <h2>Endless Quiz</h2>
          <p class='muted'>Keep going until you stop.</p>
          <button class='btn' id='startEndless'>Start Endless</button>
        </div>

        <div class='subcard'>
          <h2>Flashcards</h2>
          <p class='muted'>Tap to reveal, self-grade.</p>
          <button class='btn' id='startFlash'>Start Flashcards</button>
        </div>
      </div>
    </div>

    <div class='card ref'>
      <h2>Quick Reference ‚Äî „Åì/„Åù/„ÅÇ/„Å©</h2>
      ${refKoSoADoTable(true)}
      <h2 style='margin-top:16px'>Particles (14 core)</h2>
      ${refParticlesList(true)}
      <div class='legend'>
        <span class='muted'>Proficiency:</span>
        <div class='heat' style='grid-template-columns:repeat(10,16px);gap:4px'>
          ${[0,1,2,3,4,5,6,7,8,9].map(l=>`<div class='tile' style='height:12px;border-radius:4px;background:${levelColor(l)}'></div>`).join('')}
        </div>
        <span class='muted'>New ‚Üí Mastered</span>
      </div>
    </div>
  `;
  app.appendChild(el);
  // quick-ref links
  el.querySelectorAll('[data-ref]').forEach(a=>{
    a.onclick=(e)=>{ e.preventDefault(); viewRefFull(a.dataset.ref); };
  });
  // hydrate
  const ps=el.querySelector('#promptSel'); ps.value=S.settings.prompt; ps.onchange=()=>{S.settings.prompt=ps.value; save('settings',S.settings)};
  const qt=el.querySelector('#qtypeSel'); qt.value=S.settings.qtype; qt.onchange=()=>{S.settings.qtype=qt.value; save('settings',S.settings)};
  const cs=el.querySelector('#catSel'); cs.value=S.settings.category; cs.onchange=()=>{S.settings.category=cs.value; save('settings',S.settings)};
  el.querySelector('#sizeInp').onchange=e=>{ S.settings.size=+e.target.value; save('settings',S.settings) };
  el.querySelector('#startFixed').onclick=()=>{ startSession('FIXED'); nextQuestion(); };
  el.querySelector('#startEndless').onclick=()=>{ startSession('ENDLESS'); nextQuestion(); };
  el.querySelector('#startFlash').onclick=()=>{ startSession('FLASH'); nextQuestion(); };
}

function viewQuiz(){
  const s=S.session; const { card, promptLang, options } = s.current;
  const total = s.kind==='ENDLESS'? null : s.queue.length;
  const progress = total? Math.round((s.idx/total)*100): 0;
  const el=document.createElement('div'); el.className='grid';
  el.innerHTML=`
    ${total? `<div class='bar'><span style='width:${progress}%'></span></div>`:''}
    <div class='card'>
      <div class='q'>${promptLang==='EN' ? card.en : renderJP(card.jp)}</div>
      <div class='muted' style='margin-top:6px'>${promptLang==='EN' ? 'Pick the Japanese' : 'Pick the English'}</div>
      <div class='options'>
        ${options.map((o,i)=>`<button class='btn option' data-i='${i}'>${promptLang==='EN'? renderJP(o.jp) : o.en}</button>`).join('')}
      </div>
      <div class='hintbox'>
        <button class='btn' id='hintBtn'>${s.hintShown? 'Hide hint':'Show hint'}</button>
        <span id='hintTxt' class='muted' style='margin-left:8px;${s.hintShown? '' : 'display:none;'}'>${hintText(card, promptLang)}</span>
      </div>
      <div id='fb' class='feedback' aria-live='polite'></div>
    </div>
    ${s.kind==='ENDLESS'? `<div class='hud'><button class='btn bad' id='stopBtn'>Stop</button></div>`:''}
  `;
  app.appendChild(el);
  setGlossRoot(el);

  const btns = el.querySelectorAll('.options button');
  btns.forEach(btn=>btn.onclick=()=>{
    if(s.locked) return; s.locked=true;
    const idx=+btn.dataset.i; const correct=s.current.options[idx].id===s.current.card.id;
    // colorize & lock
    btns.forEach((b,i)=>{
      if(i===idx && !correct) b.classList.add('wrong');
      if(s.current.options[i].id===s.current.card.id) b.classList.add('correct');
      b.disabled=true;
    });
    // feedback
    const fb=el.querySelector('#fb');
    fb.className='feedback '+(correct?'good':'bad');
    fb.textContent = correct? 'Correct!' : `Correct: ${s.current.card.jp} = ${s.current.card.en}`;
    playSfx(correct);
    grade(correct, idx);

    // click card to continue (delay so current click doesn't advance)
    const cardBox = el.querySelector('.card');
    const cont = document.createElement('div');
    cont.id='clickToNext'; cont.className='muted'; cont.style.marginTop='10px';
    cont.textContent='Click anywhere in this card to continue';
    cardBox.appendChild(cont);
    const advance=()=>{
      cardBox.removeEventListener('click', advance, true);
      if(s.kind==='ENDLESS'){ nextQuestion(); } else { s.idx++; if(s.idx>=s.queue.length) finish(); else nextQuestion(); }
    };
    setTimeout(()=>cardBox.addEventListener('click', advance, true), 30);
  });

  const stopBtn = el.querySelector('#stopBtn'); if(stopBtn) stopBtn.onclick=finish;
  const hintBtn = el.querySelector('#hintBtn'); const hintTxt = el.querySelector('#hintTxt');
  hintBtn.onclick=()=>{ s.hintShown=!s.hintShown; hintTxt.style.display=s.hintShown?'inline':'none'; hintBtn.textContent=s.hintShown?'Hide hint':'Show hint'; };
}

function viewFlash(){
  const s = S.session;
  const card = s.current.card;
  const frontLang = (S.settings.prompt === 'MIXED') ? (Math.random() < 0.5 ? 'EN' : 'JA') : S.settings.prompt;
  const jp = (str)=> (typeof renderJP === 'function' ? renderJP(str) : str);

  const el = document.createElement('div'); el.className = 'grid';
  el.innerHTML = `
  <div class="card flash">
    <!-- SUBJECT stays fixed, centered, same size -->
        <div class="front" style="text-align:center;width:100%">
        ${frontLang === 'EN' ? card.en : jp(card.jp)}
        </div>

        ${!s.flipped ? `
        <div class="muted" style="margin-top:6px">
            ${frontLang === 'EN' ? card.example.en : jp(card.example.jp)}
        </div>
        <div class="row">
            <button class="btn" id="flipBtn">Show answer</button>
        </div>
        ` : `
        <div class="muted" style="margin-top:6px">
            ${frontLang === 'EN' ? jp(card.example.jp) : card.example.en}
        </div>
        <div style="font-size:26px;line-height:1.2;margin-top:8px;text-align:center">
            ${frontLang === 'EN' ? jp(card.jp) : card.en}
        </div>
        <div class="row">
            <button class="btn good" id="knewBtn">I knew it</button>
            <button class="btn bad" id="missBtn">I missed it</button>
        </div>
        `}
    </div>

    <div class="hud">
        <button class="btn bad" id="stopBtn">Stop</button>
        <button class="btn" id="undoBtn">Back</button>
    </div>
    `;
    app.appendChild(el);
    setGlossRoot(el.querySelector('.flash'));

  if (!s.flipped){
  document.getElementById('flipBtn').onclick = () => { s.flipped = true; render(); };
    } else {
    document.getElementById('knewBtn').onclick = () => {
        playSfx(true);
        const prevStreak = s.streak, prevMax = s.maxStreak;
        s.answered++; s.score++; s.streak++; if (s.streak > s.maxStreak) s.maxStreak = s.streak;
        queueMasteryUpdate(card.id, true);
        s.history.push({ cardId: card.id, ok: true, prevStreak, prevMaxStreak: prevMax, frontLang });
        nextQuestion();
    };
    document.getElementById('missBtn').onclick = () => {
        playSfx(false);
        const prevStreak = s.streak, prevMax = s.maxStreak;
        s.answered++; s.streak = 0; s.mistakes.push(card.id);
        queueMasteryUpdate(card.id, false);
        s.history.push({ cardId: card.id, ok: false, prevStreak, prevMaxStreak: prevMax, frontLang });
        nextQuestion();
    };
    }
    document.getElementById('stopBtn').onclick = finish;
    document.getElementById('undoBtn').onclick = undoFlash;
}

function viewResults(){
  const s=S.session; const accPct=s.finished.total?Math.round(100*s.score/s.finished.total):0;
  const el=document.createElement('div'); el.className='grid';
  el.innerHTML=`
    <div class='card grid'>
      <div class='row'>
        <div><b>Accuracy:</b> ${s.score}/${s.finished.total} (${accPct}%)</div>
        <div><b>Longest Streak:</b> ${s.maxStreak}</div>
        <div><b>Mode:</b> ${S.settings.prompt} ¬∑ ${S.settings.qtype} ¬∑ ${S.settings.category}</div>
        <div><b>Duration:</b> ${Math.round(s.finished.duration/1000)}s</div>
      </div>

      <h2>Mastery change</h2>
      ${s.delta ? masteryChangeHTML(s.delta.before, s.delta.after) : ''}

      <h2>Missed items</h2>
      <div class='grid'>${(s.mistakes.length? Array.from(new Set(s.mistakes)) : ['(none)']).map(id=>{
        if(id==='(none)') return `<div class='muted'>(none)</div>`;
        const card=[...DECK].find(x=>x.id===id);
        return `<div class='card' style='padding:12px'>
          <div><b>${card.jp}</b> ‚Äî ${card.en} <span class='chip' style='background:${levelColor((S.mastery[id]||{lvl:0}).lvl)};color:${textColor((S.mastery[id]||{lvl:0}).lvl)}'>L${(S.mastery[id]||{lvl:0}).lvl}</span></div>
          <div class='muted'>${renderJP(card.example.jp)} / ${card.example.en}</div>
        </div>`;
      }).join('')}</div>

      <div class='row'>
        <button class='btn primary' id='retryBtn'>Retry mistakes</button>
        <button class='btn' id='menuBtn'>Back to menu</button>
        <button class='btn' id='refBtn'>Review reference</button>
      </div>
    </div>
  `;
  app.appendChild(el);
  el.querySelector('#menuBtn').onclick=()=>{ S.session=null; render(); };
  el.querySelector('#refBtn').onclick=()=>{ S.session=null; render(); };
  el.querySelector('#retryBtn').onclick=()=>{
    const unique=Array.from(new Set(s.mistakes));
    if(unique.length===0){ S.session=null; render(); return; }
    S.session={ kind:'FIXED', queue: unique.map(id=>DECK.find(c=>c.id===id)), idx:0, score:0, streak:0, maxStreak:0, mistakes:[], recent:[], started:Date.now(), answered:0, phase:'ASK', hintShown:false };
    nextQuestion();
  };
}

function viewRefFull(group){
  const starts = {KO:'„Åì', SO:'„Åù', A:'„ÅÇ', DO:'„Å©'}[group];
  const items = DEMO.filter(x=> x.jp.startsWith(starts));
  const el = document.createElement('div'); 
  app.dataset.refGroup = group;
  el.className='grid';
  el.innerHTML = `
    <div class='card'>
      <h2>Full Reference ‚Äî ${starts}Ôºä</h2>
      <div class='grid'>
        ${items.map(it=>`
          <div class='card' style='padding:12px'>
            <div><b>${it.jp}</b> ‚Äî ${it.en}</div>
            <div class='muted'>${it.hint||''}</div>
            <div style='margin-top:6px'>${renderJP(it.example.jp)}</div>
            <div class='muted'>${it.example.en}</div>
          </div>
        `).join('')}
      </div>
      <div class='row' style='margin-top:10px'>
        <button class='btn' id='backToMenu'>Back</button>
      </div>
    </div>`;
  app.innerHTML=''; app.appendChild(el);
  setGlossRoot(el);


  el.querySelector('#backToMenu').onclick = () => {
  delete app.dataset.refGroup;
  S.session = null;
  render();
};

}

// ======================= REFERENCE TABLES =======================
function refKoSoADoTable(showMastery){
  const rows = [
    ['Thing (‚Äìre)', ['„Åì„Çå','„Åù„Çå','„ÅÇ„Çå','„Å©„Çå'], ['kore','sore','are','dore']],
    ['Modifier (‚Äìno)', ['„Åì„ÅÆ','„Åù„ÅÆ','„ÅÇ„ÅÆ','„Å©„ÅÆ'], ['kono','sono','ano','dono']],
    ['Place (‚Äìko)', ['„Åì„Åì','„Åù„Åì','„ÅÇ„Åù„Åì','„Å©„Åì'], ['koko','soko','asoko','doko']],
    ['Direction (‚Äìchira)', ['„Åì„Å°„Çâ','„Åù„Å°„Çâ','„ÅÇ„Å°„Çâ','„Å©„Å°„Çâ'], ['kochira','sochira','achira','dochira']],
    ['Manner (‚Äìu)', ['„Åì„ÅÜ','„Åù„ÅÜ','„ÅÇ„ÅÇ','„Å©„ÅÜ'], ['kou','sou','aa','dou']],
    ['Kind (‚Äìnna)', ['„Åì„Çì„Å™','„Åù„Çì„Å™','„ÅÇ„Çì„Å™','„Å©„Çì„Å™'], ['konna','sonna','anna','donna']],
    ['Degree (‚Äìnani)', ['„Åì„Çì„Å™„Å´','„Åù„Çì„Å™„Å´','„ÅÇ„Çì„Å™„Å´','„Å©„Çì„Å™„Å´'], ['konnani','sonnani','annani','donnani']],
  ];
  let html = `<table><tr>
    <th></th>
    <th><a href="#" data-ref="KO">„Åì (near me)</a></th>
    <th><a href="#" data-ref="SO">„Åù (near you)</a></th>
    <th><a href="#" data-ref="A">„ÅÇ (far)</a></th>
    <th><a href="#" data-ref="DO">„Å© (which)</a></th>
  </tr>`;
  for(const [label, jp, ids] of rows){
    html += `<tr><th>${label}</th>` + jp.map((s,i)=>{
      const id = ids[i]; const lvl = (S.mastery[id]?.lvl)||0; const bg = showMastery? ` style='background:${levelColor(lvl)};color:${textColor(lvl)}'` : '';
      return `<td${bg}>${s}</td>`;
    }).join('') + `</tr>`;
  }
  html += `</table>`; return html;
}

function refParticlesList(showMastery){
  return `<table><tr><th>Particle</th><th>Role</th><th>Example</th></tr>` + PARTICLES.map(p=>{
    const lvl = (S.mastery[p.id]?.lvl)||0; const style = showMastery? ` style='background:${levelColor(lvl)};color:${textColor(lvl)}'` : '';
    return `<tr${style}><td><b>${p.jp}</b></td><td>${p.en}</td><td>${renderJP(p.example.jp)}</td></tr>`;
  }).join('') + `</table>`;
}

// ======================= UTIL =======================
function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } return a; }
function levelColor(l){ const colors=['#FFFFFF','#eaf7ee','#d5efdd','#bde5c8','#a6dbb4','#8fd1a0','#73c488','#52b371','#319f58','#148942']; return colors[Math.max(0,Math.min(9,l|0))]; }
function textColor(l){ return (l>=6)? '#ffffff' : '#0b1220'; }
function hintText(card, promptLang){ return (promptLang==='EN') ? `<b>${card.en}</b> ‚Äî e.g., ${card.example.en}` : `‰æã: ${renderJP(card.example.jp)}`; }
function snapshotMastery(){ const map={}; for(const c of DECK) map[c.id]=(S.mastery[c.id]?.lvl)||0; return map; }
function masteryCountsFrom(map){ const counts=Array(10).fill(0); for(const id in map){ counts[Math.max(0,Math.min(9,map[id]|0))]++; } return counts; }
function masteryChangeHTML(beforeMap, afterMap){
  const before=masteryCountsFrom(beforeMap); const after=masteryCountsFrom(afterMap);
  return `<div class='heat mc'>
    ${after.map((n,l)=>{ const d=n-(before[l]||0); const cls=d>0?'up':d<0?'down':'flat'; const textWhite=l>=6?'color:#fff;':''; const deltaTxt=d>0?`+`+d:d<0?String(d):'¬±0';
      return `<div class='tile' style='background:${levelColor(l)};height:28px;display:flex;flex-direction:column;align-items:center;justify-content:center' title='L${l}: ${n} now (${deltaTxt})'>
        <div style='font-size:12px;${textWhite}'>${n}</div>
        <div class='mc-delta ${cls}' style='font-size:11px'>${deltaTxt}</div>
      </div>`; }).join('')}
  </div>`;
}

// ===== Bottom glossary bar (global, reliable on iOS) =====
const _isIOS = /iP(hone|ad|od)/.test(navigator.userAgent);
let _glossRoot = null;   // current container we care about (set per view)

function setGlossRoot(root){
  _glossRoot = root || null;
  if(!_glossRoot) hideGlossbar();
}

function ensureGlossbar(){
  let gb = document.getElementById('glossbar');
  if(!gb){
    gb = document.createElement('div');
    gb.id = 'glossbar';
    gb.className = 'glossbar';
    gb.innerHTML = `<div class="chips" id="glosschips"></div>`;
    document.body.appendChild(gb);
  }
  return gb;
}
function hideGlossbar(){
  const gb = ensureGlossbar();
  gb.style.display = 'none';
  const chips = document.getElementById('glosschips');
  if(chips) chips.innerHTML = '';
}
function showGlossbar(tokens){
  const gb = ensureGlossbar();
  const chips = document.getElementById('glosschips');
  chips.innerHTML = tokens.map(t => `<span class="chip">${t.jp} ‚Äî ${t.en}</span>`).join('');
  gb.style.display = tokens.length ? 'block' : 'none';
}

function extractGlossTokens(text){
  if(!text) return [];
  const src = [...(window.DECK||[])];
  const lex = (window.LEXICON||{});
  for(const k in lex){ src.push({ jp:k, en:lex[k] }); }
  const uniq = new Map();
  for(const entry of src){
    if(!entry.jp) continue;
    if(text.includes(entry.jp)) uniq.set(entry.jp, { jp: entry.jp, en: entry.en });
  }
  return Array.from(uniq.values()).slice(0, 16);
}

// Aggressive iOS callout dismiss (selection + temporary blur)
function clearIOSSelection(){
  if(!_isIOS) return;
  const nuke = () => {
    try{ const sel=window.getSelection(); sel && sel.removeAllRanges(); }catch(_){}
    if(document.activeElement && document.activeElement.blur) document.activeElement.blur();
  };
  // try a few frames; Safari can be stubborn
  requestAnimationFrame(()=>{ nuke(); setTimeout(nuke, 50); setTimeout(nuke, 120); });
}

// Single global selection handler; only reacts if selection is inside _glossRoot
function handleSelection(){
  const sel = window.getSelection();
  if(!sel || sel.rangeCount === 0){ hideGlossbar(); return; }
  const node = sel.anchorNode && sel.anchorNode.nodeType === 3 ? sel.anchorNode.parentNode : sel.anchorNode;
  if(!_glossRoot || !node || !_glossRoot.contains(node)){ hideGlossbar(); return; }

  const raw = sel.toString().trim();
  if(!raw){ hideGlossbar(); return; }

  const tokens = extractGlossTokens(raw);
  if(tokens.length === 0){ hideGlossbar(); return; }

  showGlossbar(tokens);
  clearIOSSelection();
}

// Install once
(function initGlossaryListener(){
  document.addEventListener('selectionchange', handleSelection);
  // Also catch keyboard/mouse/touch ends
  ['mouseup','keyup','touchend'].forEach(ev => document.addEventListener(ev, handleSelection, {passive:true}));
})();


// Harvest tokens from selected text using DECK + LEXICON
function extractGlossTokens(text){
  if(!text) return [];
  const src = [...(window.DECK||[])];
  const lex = (window.LEXICON||{});
  // add lexicon entries as pseudo-cards
  for(const k in lex){ src.push({ jp:k, en:lex[k] }); }

  const uniq = new Map();
  for(const entry of src){
    if(!entry.jp) continue;
    if(text.includes(entry.jp)) uniq.set(entry.jp, { jp: entry.jp, en: entry.en });
  }
  return Array.from(uniq.values()).slice(0, 12); // keep it compact
}

// ======================= SFX =======================
const SFX = { good:new Audio('sfx/correct.mp3'), bad:new Audio('sfx/incorrect.mp3') };
function playSfx(ok){ if(S.settings.muted) return; try{ const a=ok?SFX.good:SFX.bad; a.currentTime=0; a.play(); }catch(e){} }

// ======================= SELECTION POPUP (greedy lexicon) =======================
function isJP(text){ return /[\u3040-\u30ff\u3400-\u4dbf\u4e00-\u9faf]/.test(text); }
function segmentJP(sel){
  const txt=sel.trim(); const out=[]; let i=0;
  while(i<txt.length){
    let hit=null, hitLen=0;
    for(const k of LEX_KEYS){ if(txt.startsWith(k,i)){ hit=k; hitLen=k.length; break; } }
    if(hit){ out.push({jp:hit,en:LEX[hit]||null}); i+=hitLen; continue; }
    const ch=txt[i]; if(KANJILEX[ch]) out.push({jp:ch,en:KANJILEX[ch]}); else out.push({jp:ch,en:null}); i+=1;
  }
  return out;
}
let _selPop=null;
function showSelPop(x,y,html){
  if(!_selPop){ _selPop=document.createElement('div'); _selPop.className='selpop'; document.body.appendChild(_selPop); }
  _selPop.innerHTML=html; const vw=innerWidth, vh=innerHeight;
  _selPop.style.left=Math.min(vw-10,Math.max(10,x))+'px';
  _selPop.style.top=Math.min(vh-10,Math.max(10,y))+'px';
  _selPop.style.transform='translate(-50%,0)'; _selPop.style.display='block';
}
function hideSelPop(){ if(_selPop) _selPop.style.display='none'; }
function handleSelection(){
  setTimeout(()=>{ const sel=getSelection(); if(!sel||sel.isCollapsed){ hideSelPop(); return; }
    const txt=sel.toString().trim(); if(!txt||!isJP(txt)){ hideSelPop(); return; }
    const rect=sel.getRangeAt(0).getBoundingClientRect();
    const tokens=segmentJP(txt); const jp=(s)=>renderJP?s: s;
    const html=`<div class="tt">${renderJP(txt)}</div>
      <div style="display:flex;flex-wrap:wrap;gap:6px;margin-top:6px">
        ${tokens.map(t=>`<div style="border:1px solid #2a3141;border-radius:8px;padding:6px 8px;background:var(--chip)">
          <div>${renderJP(t.jp)}</div>
          <div class="ex">${t.en?t.en:'<span class="muted">‚Äî</span>'}</div>
        </div>`).join('')}
      </div>`;
    showSelPop(rect.left+rect.width/2, rect.bottom+8, html);
  },0);
}
function initSelectionPopup(){
  document.addEventListener('mouseup', handleSelection);
  document.addEventListener('touchend', handleSelection);
  document.addEventListener('keydown', e=>{ if(e.key==='Escape') hideSelPop(); });
  document.addEventListener('scroll', hideSelPop, true);
}

// ======================= TITLE NAV =======================
const titleEl=document.querySelector('.title h1');
titleEl.style.cursor='pointer';
titleEl.onclick=()=>{
  if(S.session){
    const ok=confirm('End current session and return to the main menu?');
    if(!ok) return; applyPending(); S.session=null;
  }
  render();
};

// ======================= BOOT =======================
render(); // placeholder
loadData().then(()=>{ DATA_READY=true; render(); initSelectionPopup(); });
</script>
</body>
</html>
